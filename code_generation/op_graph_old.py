from collections import defaultdict

class OpEdge:
    def __init__(self) -> None:
        pass

DEFAULT_OP = 'ph'
BINARY_OP = ['add','sub','multi']
UNARY_OP = ['cos','sin','abs','tan']

class OpNode:
    def __init__(self,op_name,node_id=None,input_tensors=None,output_tensors=None) -> None:
        self.op_name = op_name
        self.node_id = f'{op_name}_{node_id}'
    
        # self.input_tensors = input_tensors
        # self.output_tensors = output_tensors

    def __str__(self) -> str:
        return f'{self.op_name}_{self.node_id}'


class OpGraph:
    def __init__(self) -> None:
        self.counter = 0
        self.adjacency_list = defaultdict(list)
        self.in_degree = {}
        self.leaf_list = [] # (output)
        self.node_list = []
        self.input_list = [] # te.placehoder(input)

    def __str__(self) -> str:
        result = ""
        for node, neighbors in self.adjacency_list.items():
            result += f"{node}: {neighbors}\n"
        return result
    
    def add_vertex(self, op_name):
        # init node info
        node = OpNode(op_name,self.counter)
        self.counter += 1

        self.adjacency_list[node] = []
        self.in_degree[node] = 0
        """1. add te.placehoder(input)"""
        """2. add a new op"""
        # (1) using the output generated by op in leaf_list
        if not self.node_list:
            new_node = OpNode('ph',self.counter)
            self.adjacency_list[new_node] = []
            self.in_degree[new_node] = 0
            self.counter += 1
            self.node_list.append(new_node.node_id)
            self.add_edge(new_node,node)
        else:
            pass
        # (2) using new te.placehoder(generate new te.placehoder(input) to satisfy it)
        if node.op_name in BINARY_OP:
            new_node1 = OpNode('ph',self.counter)
            self.adjacency_list[new_node1] = []
            self.in_degree[new_node1] = 0
            self.counter += 1
            self.node_list.append(new_node1.node_id)
            self.add_edge(new_node1,node)

            new_node2 = OpNode('ph',self.counter)
            self.adjacency_list[new_node2] = []
            self.in_degree[new_node2] = 0
            self.counter += 1
            self.node_list.append(new_node2.node_id)
            self.add_edge(new_node2,node)

            # self.leaf_list.remove(node.node_id)
        
        self.node_list.append(node.node_id) # the newly selected op must be a leaf node
        print('self.leaf_list:', self.leaf_list)
        print('self.node_list:', self.node_list)

    def add_edge(self,source_node,target_node):
        self.adjacency_list[source_node].append(target_node)
        self.in_degree[target_node] += 1

    def select_node(self,node_ids):
        return [node for node in self.node_list if node.node_id in node_ids]

    def topological_sort(self):
        queue = [vertex for vertex in self.in_degree if self.in_degree[vertex] == 0]
        topological_order = []

        while queue:
            vertex = queue.pop(0)
            topological_order.append(vertex.node_id)

            for neighbor in self.adjacency_list[vertex]:
                self.in_degree[neighbor] -= 1
                if self.in_degree[neighbor] == 0:
                    queue.append(neighbor)

        if len(topological_order) != len(self.in_degree):
            return None  # 存在环,无法求出拓扑序列
        else:
            return topological_order

if __name__ == '__main__':
    """Fixed Combination"""
    op_graph = OpGraph()
    op_graph.add_vertex('cos')
    op_graph.add_vertex('abs')
    op_graph.add_vertex('add')
    op_graph.add_vertex('sin')
    # op_graph.add_edge('cos','add')
    # op_graph.add_edge('abs','add')
    # op_graph.add_edge('add','sin')
    # op_graph.add_vertex(OpNode('ph'))
    # op_graph.add_vertex(OpNode('cos'))
    # op_graph.add_vertex(OpNode('abs'))
    # op_graph.add_vertex(OpNode('add'))
    # op_graph.add_vertex('abs')
    # op_graph.add_vertex('add')
    # op_graph.add_vertex('sin')
    # op_graph.add_edge('cos','add')
    # op_graph.add_edge('abs','add')
    # op_graph.add_edge('add','sin')
    # # 获取拓扑序列
    topo_order = op_graph.topological_sort()
    print(op_graph)
    if topo_order:
        print("Topological order:", topo_order)
    else:
        print("Graph contains a cycle, no topological order exists.")
    """Flexible Combination"""




# import networkx as nx
# import matplotlib.pyplot as plt

# # 创建一个无向图
# G = nx.Graph()

# # 添加节点
# G.add_nodes_from([1, 2, 3, 4, 5])

# # 添加边
# G.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)])

# # 绘制拓扑图
# pos = nx.spring_layout(G)
# nx.draw(G, pos, with_labels=True)
# plt.savefig('./graph.png')
# plt.show()

# from collections import defaultdict

# class DirectedGraph:
#     def __init__(self):
#         self.adjacency_list = defaultdict(list)
#         self.in_degree = {}

#     def add_vertex(self, vertex):
#         self.adjacency_list[vertex] = []
#         self.in_degree[vertex] = 0

#     def add_edge(self, source, destination):
#         self.adjacency_list[source].append(destination)
#         self.in_degree[destination] += 1

#     def topological_sort(self):
#         queue = [vertex for vertex in self.in_degree if self.in_degree[vertex] == 0]
#         topological_order = []

#         while queue:
#             vertex = queue.pop(0)
#             topological_order.append(vertex)

#             for neighbor in self.adjacency_list[vertex]:
#                 self.in_degree[neighbor] -= 1
#                 if self.in_degree[neighbor] == 0:
#                     queue.append(neighbor)

#         if len(topological_order) != len(self.in_degree):
#             return None  # 存在环,无法求出拓扑序列
#         else:
#             return topological_order

# # 创建一个有向图
# directed_graph = DirectedGraph()

# # 添加顶点
# directed_graph.add_vertex('A')
# directed_graph.add_vertex('B')
# directed_graph.add_vertex('C')
# directed_graph.add_vertex('D')
# directed_graph.add_vertex('E')
# directed_graph.add_vertex('F')

# # 添加边
# directed_graph.add_edge('A', 'B')
# directed_graph.add_edge('B', 'C')
# directed_graph.add_edge('F', 'B')
# directed_graph.add_edge('C', 'D')
# directed_graph.add_edge('D', 'E')
# directed_graph.add_edge('B', 'E')

# # 获取拓扑序列
# topo_order = directed_graph.topological_sort()
# if topo_order:
#     print("Topological order:", topo_order)
# else:
#     print("Graph contains a cycle, no topological order exists.")